#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) IBM Corporation 2020
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import absolute_import, division, print_function
__metaclass__ = type


DOCUMENTATION = r'''
---
module: zos_blockinfile
author:
  - "Behnam (@balkajbaf)"
short_description: Manage block of multi-line textual data on z/OS
description:
  - Manage block of multi-lines in z/OS UNIX System Services (USS) files,
    PS (sequential data set), PDS, PDSE, or member of a PDS or PDSE.
  - This module ensures a particular block of multi-line text surrounded
    by customizable marker lines is present in a USS file or data set, or
    replaces an existing block identified by the markers.
  - This is primarily useful when you want to change a block of multi-line
    text in a USS file or data set.
options:
  src:
    description:
      - The location can be a UNIX System Services (USS) file,
        PS (sequential data set), member of a PDS or PDSE, PDS, PDSE.
      - The USS file must be an absolute pathname.
    type: str
    aliases: [ path, destfile, name ]
    required: true
  state:
    description:
      - Whether the block should be inserted/replaced (present) or removed (absent).
    type: str
    choices:
      - absent
      - present
    default: present
  marker:
    description:
    - The marker line template.
    - C({mark}) will be replaced with the values C(in marker_begin)
      (default="BEGIN") and C(marker_end) (default="END").
    - Using a custom marker without the C({mark}) variable may result
      in the block being repeatedly inserted on subsequent playbook runs.
    required: false
    type: str
    default: '# {mark} ANSIBLE MANAGED BLOCK'
  block:
    description:
    - The text to insert inside the marker lines.
    - Multi-line can be separated by '\n'.
    required: false
    type: str
    default: ''
    aliases: [ content ]
  insertafter:
    description:
    - If specified, the block will be inserted after the last match of the specified
      regular expression.
    - A special value C(EOF) for inserting a block at the end of the file is
      available.
    - If a specified regular expression has no matches, C(EOF) will be used instead.
    - Choices are EOF or '*regex*'.
    - Default is EOF.
    required: false
    type: str
  insertbefore:
    description:
    - If specified, the block will be inserted before the last match of specified
      regular expression.
    - A special value C(BOF) for inserting the block at the beginning of the file
      is available.
    - If a specified regular expression has no matches, the block will be inserted
      at the end of the file.
    - Choices are BOF or '*regex*'.
    required: false
    type: str
  marker_begin:
    description:
    - This will be inserted at C({mark}) in the opening ansible block marker.
    required: false
    type: str
    default: BEGIN
  marker_end:
    required: false
    description:
    - This will be inserted at C({mark}) in the closing ansible block marker.
    type: str
    default: END
  backup:
    description:
      - Specifies whether a backup of destination should be created before
        editing the source I(src).
      - When set to C(true), the module creates a backup file or data set.
      - The backup file name will be returned on either success or failure of
        module execution such that data can be retrieved.
    required: false
    type: bool
    default: false
  backup_name:
    description:
      - Specify the USS file name or data set name for the destination backup.
      - If the source I(src) is a USS file or path, the backup_name name must be a file
        or path name, and the USS file or path must be an absolute path name.
      - If the source is an MVS data set, the backup_name name must be an MVS
        data set name.
      - If the backup_name is not provided, the default backup_name name will
        be used. If the source is a USS file or path, the name of the backup
        file will be the source file or path name appended with a
        timestamp, e.g. C(/path/file_name.2020-04-23-08-32-29-bak.tar).
      - If the source is an MVS data set, it will be a data set with a random
        name generated by calling the ZOAU API. The MVS backup data set
        recovery can be done by renaming it.
      - If I(src) is a data set member and backup_name is not provided, the data set
        member will be backed up to the same partitioned data set with a randomly generated
        member name.
    required: false
    type: str
  encoding:
    description:
      - The character set of the source I(src). M(zos_blockinfile)
        requires to be provided with correct encoding to read the content
        of USS file or data set. If this parameter is not provided, this
        module assumes that USS file or data set is encoded in IBM-1047.
      - Supported character sets rely on the charset conversion utility (iconv)
        version; the most common character sets are supported.
    required: false
    type: str
    default: IBM-1047
notes:
  - It is the playbook author or user's responsibility to avoid files
    that should not be encoded, such as binary files. A user is described
    as the remote user, configured either for the playbook or playbook
    tasks, who can also obtain escalated privileges to execute as root
    or another user.
  - All data sets are always assumed to be cataloged. If an uncataloged data set
    needs to be encoded, it should be cataloged first. The M(zos_data_set) module
    can be used to catalog uncataloged data sets.
  - For supported character sets used to encode data, refer to the
    L(documentation,https://ibm.github.io/z_ansible_collections_doc/ibm_zos_core/docs/source/resources/character_set.html).
  - When using 'with_*' loops be aware that if you do not set a unique mark
    the block will be overwritten on each iteration.
  - When more then one block should be handled in a file you must change
    the I(marker) per task.
seealso:
- module: zos_data_set
'''

EXAMPLES = r'''
- name: Insert/Update new mount point
  zos_blockinfile:
    src: SYS1.PARMLIB(BPXPRM00)
    marker: "/* {mark} ANSIBLE MANAGED BLOCK */"
    block: |
       MOUNT FILESYSTEM('SOME.DATA.SET') TYPE(ZFS) MODE(READ)
          MOUNTPOINT('/tmp/src/somedirectory')

- name: Remove a library as well as surrounding markers
  zos_blockinfile:
    state: absent
    src: SYS1.PARMLIB(PROG00)
    marker: "/* {mark} ANSIBLE MANAGED BLOCK FOR SOME.DATA.SET */"

- name: Add ZOAU path to PATH in /etc/profile
  zos_blockinfile:
    src: /etc/profile
    insertafter: "PATH="
    block: |
      ZOAU=/path/to/zoau_dir/bin
      export ZOAU
      PATH=$ZOAU:$PATH

- name: Insert/Update HTML surrounded by custom markers after <body> line
  zos_blockinfile:
    path: /var/www/html/index.html
    marker: "<!-- {mark} ANSIBLE MANAGED BLOCK -->"
    insertafter: "<body>"
    block: |
      <h1>Welcome to {{ ansible_hostname }}</h1>
      <p>Last updated on {{ ansible_date_time.iso8601 }}</p>

- name: Remove HTML as well as surrounding markers
  zos_blockinfile:
    path: /var/www/html/index.html
    state: absent
    marker: "<!-- {mark} ANSIBLE MANAGED BLOCK -->"

- name: Add mappings to /etc/hosts
  zos_blockinfile:
    path: /etc/hosts
    block: |
      {{ item.ip }} {{ item.name }}
    marker: "# {mark} ANSIBLE MANAGED BLOCK {{ item.name }}"
  loop:
    - { name: host1, ip: 10.10.1.10 }
    - { name: host2, ip: 10.10.1.11 }
    - { name: host3, ip: 10.10.1.12 }
'''

RETURN = r"""
changed:
  description: Indicates if the source was modified
  returned: success
  type: bool
  sample: 1
found:
  description: Number of the matching patterns
  returned: success
  type: int
  sample: 5
cmd:
  description: Constructed ZOAU dmod shell command based on the parameters
  returned: success
  type: str
  sample: dmodhelper -d -b -c IBM-1047 -m "BEGIN\nEND\n# {mark} ANSIBLE MANAGED BLOCK" -e "$ a\\PATH=/dir/bin:$PATH" /etc/profile
msg:
  description: The module messages
  returned: failure
  type: str
  sample: Parameter verification failed
stdout:
  description: The stdout from ZOAU dmod when json.loads() fails to parse the result from dmod
  returned: failure
  type: str
stderr:
  description: The error messages from ZOAU dmod
  returned: failure
  type: str
  sample: BGYSC1311E Iconv error, cannot open converter from ISO-88955-1 to IBM-1047
rc:
  description: The return code from ZOAU dmod when json.loads() fails to parse the result from dmod
  returned: failure
  type: bool
backup_name:
    description: Name of the backup file or data set that was created.
    returned: if backup=true, always
    type: str
    sample: /path/to/file.txt.2015-02-03@04:15~
"""

import json
from ansible.module_utils.six import b
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils._text import to_bytes
from ansible.module_utils.six import PY3
from ansible_collections.ibm.ibm_zos_core.plugins.module_utils import (
    better_arg_parser, data_set, backup as Backup)
from os import path
from ansible_collections.ibm.ibm_zos_core.plugins.module_utils.import_handler import (
    MissingZOAUImport,
)
from ansible_collections.ibm.ibm_zos_core.plugins.module_utils.better_arg_parser import (
    BetterArgParser,
)

try:
    from zoautil_py import datasets
except Exception:
    Datasets = MissingZOAUImport()

if PY3:
    from shlex import quote
else:
    from pipes import quote

# supported data set types
DS_TYPE = ['PS', 'PO']


def present(src, block, marker, ins_aft, ins_bef, encoding):
    """Replace a block with the matching regex pattern
    Insert a block before/after the matching pattern
    Insert a block at BOF/EOF

    Arguments:
        src: {str} -- The z/OS USS file or data set to modify.
        block: {str} -- The block to insert/replace into the src.
        marker: {str} -- The block will be inserted/updated with the markers.
        ins_aft: {str} -- Insert the block after matching '*regex*' pattern or EOF.
            choices:
                - EOF
                - '*regex*'
        ins_bef: {str} -- Insert the block before matching '*regex*' pattern or BOF.
            choices:
                - BOF
                - '*regex*'
        encoding: {str} -- Encoding of the src.

    Returns:
        str -- Information in JSON format. keys:
            cmd: {str} -- dmod shell command
            found: {int} -- Number of matching regex pattern
            changed: {bool} -- Indicates if the destination was modified.
    """
    return datasets.blockinfile(src, block=block, marker=marker, ins_aft=ins_aft, ins_bef=ins_bef, encoding=encoding, state=True, debug=True)


def absent(src, marker, encoding):
    """Delete blocks with matching regex pattern

    Arguments:
        src: {str} -- The z/OS USS file or data set to modify.
        marker: {str} -- Identifies the block to be removed.
        encoding: {str} -- Encoding of the src.

    Returns:
        str -- Information in JSON format. keys:
            cmd: {str} -- dmod shell command
            found: {int} -- Number of matching regex pattern
            changed: {bool} -- Indicates if the destination was modified.
    """
    return datasets.blockinfile(src, marker=marker, encoding=encoding, state=False, debug=True)


def quotedString(string):
    # add escape if string was quoted
    if not isinstance(string, str):
        return string
    return string.replace('"', '\\\"')


def main():
    module = AnsibleModule(
        argument_spec=dict(
            src=dict(
                type='str',
                required=True,
                aliases=['path', 'destfile', 'name']
            ),
            state=dict(
                type='str',
                default='present',
                choices=['absent', 'present']
            ),
            marker=dict(
                type='str',
                default='# {mark} ANSIBLE MANAGED BLOCK'
            ),
            block=dict(
                type='str',
                default='',
                aliases=['content']
            ),
            insertafter=dict(
                type='str'
            ),
            insertbefore=dict(
                type='str'
            ),
            marker_begin=dict(
                type='str',
                default='BEGIN'
            ),
            marker_end=dict(
                type='str',
                default='END'
            ),
            backup=dict(
                type='bool',
                default=False
            ),
            backup_name=dict(
                type='str',
                required=False,
                default=None
            ),
            encoding=dict(
                type='str',
                default='IBM-1047'
            ),
        ),
        mutually_exclusive=[['insertbefore', 'insertafter']],
    )

    params = module.params

    arg_defs = dict(
        src=dict(arg_type='data_set_or_path', aliases=['path', 'destfile', 'name'], required=True),
        state=dict(arg_type='str', default='present', choices=['absent', 'present']),
        marker=dict(arg_type='str', default='# {mark} ANSIBLE MANAGED BLOCK', required=False),
        block=dict(arg_type='str', default='', aliases=['content'], required=False),
        insertafter=dict(arg_type='str', required=False),
        insertbefore=dict(arg_type='str', required=False),
        marker_begin=dict(arg_type='str', default='BEGIN', required=False),
        marker_end=dict(arg_type='str', default='END', required=False),
        encoding=dict(arg_type='str', default='IBM-1047', required=False),
        backup=dict(arg_type='bool', default=False, required=False),
        backup_name=dict(arg_type='data_set_or_pat', required=False, default=None),
        mutually_exclusive=[['insertbefore', 'insertafter']],
    )
    result = dict(changed=False, cmd='', found=0)
    try:
        parser = better_arg_parser.BetterArgParser(arg_defs)
        parsed_args = parser.parse_args(module.params)
    except ValueError as err:
        module.fail_json(msg="Parameter verification failed", stderr=str(err))

    backup = parsed_args.get('backup')
    if parsed_args.get('backup_name') and backup:
        backup = parsed_args.get('backup_name')
    src = parsed_args.get('src')
    ins_aft = parsed_args.get('insertafter')
    ins_bef = parsed_args.get('insertbefore')
    encoding = parsed_args.get('encoding')
    block = parsed_args.get('block')
    marker = parsed_args.get('marker')
    marker_begin = parsed_args.get('marker_begin')
    marker_end = parsed_args.get('marker_end')

    if not block and parsed_args.get('state') == 'present':
        module.fail_json(msg='block is required with state=present')
    if not marker:
        marker = '# {mark} ANSIBLE MANAGED BLOCK'
    if "{mark}" not in marker:
        module.fail_json(msg='marker should have {mark}')
    # make sure the default encoding is set if empty string was passed
    if not encoding:
        encoding = "IBM-1047"
    if not ins_aft and not ins_bef and parsed_args.get('state') == 'present':
        ins_aft = "EOF"
    if not marker_begin:
        marker_begin = 'BEGIN'
    if not marker_end:
        marker_end = 'END'

    marker = "{0}\\n{1}\\n{2}".format(marker_begin, marker_end, marker)
    blocklines = block.splitlines()
    block = '\\n'.join(blocklines)

    # analysis the file type
    ds_utils = data_set.DataSetUtils(src)
    if not ds_utils.exists():
        message = "{0} does NOT exist".format(str(src))
        module.fail_json(msg=message)
    file_type = ds_utils.ds_type()
    if file_type == 'USS':
        file_type = 1
    else:
        if file_type not in DS_TYPE:
            message = "{0} data set type is NOT supported".format(str(file_type))
            module.fail_json(msg=message)
        file_type = 0

    if backup:
        # backup can be True(bool) or none-zero length string. string indicates that backup_name was provided.
        # setting backup to None if backup_name wasn't provided. if backup=None, Backup module will use
        # pre-defined naming scheme and return the created destination name.
        if isinstance(backup, bool):
            backup = None
        try:
            if file_type:
                result['backup_name'] = Backup.uss_file_backup(src, backup_name=backup, compress=False)
            else:
                result['backup_name'] = Backup.mvs_file_backup(dsn=src, bk_dsn=backup)
        except Exception:
            module.fail_json(msg="creating backup has failed")
    # state=present, insert/replace a block with matching regex pattern
    # state=absent, delete blocks with matching regex pattern
    if parsed_args.get('state') == 'present':
        return_content = present(src, quotedString(block), quotedString(marker), quotedString(ins_aft), quotedString(ins_bef), encoding)
    else:
        return_content = absent(src, quotedString(marker), encoding)
    stdout = return_content.stdout_response
    stderr = return_content.stderr_response
    rc = return_content.rc
    try:
        # change the return string to be loadable by json.loads()
        stdout = stdout.replace('/c\\', '/c\\\\')
        stdout = stdout.replace('/a\\', '/a\\\\')
        stdout = stdout.replace('/i\\', '/i\\\\')
        stdout = stdout.replace('$ a\\', '$ a\\\\')
        stdout = stdout.replace('1 i\\', '1 i\\\\')
        if block:
            stdout = stdout.replace(block, quotedString(block))
        if ins_aft:
            stdout = stdout.replace(ins_aft, quotedString(ins_aft))
        if ins_bef:
            stdout = stdout.replace(ins_bef, quotedString(ins_bef))
        # Try to extract information from stdout
        ret = json.loads(stdout)
        result['cmd'] = ret['cmd']
        result['changed'] = ret['changed']
        result['found'] = ret['found']
        # Only return 'rc' if stderr is not empty to not fail the playbook run in a nomatch case
        # That information will be given with 'changed' and 'found'
        if len(stderr):
            result['stderr'] = str(stderr)
            result['rc'] = rc
    except Exception:
        messageDict = dict(msg="ZOAU dmod return content is NOT in json format", stdout=str(stdout), stderr=str(stderr), rc=rc)
        if result.get('backup_name'):
            messageDict['backup_name'] = result['backup_name']
        module.fail_json(**messageDict)
    module.exit_json(**result)


if __name__ == '__main__':
    main()
