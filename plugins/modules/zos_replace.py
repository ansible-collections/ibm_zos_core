#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) IBM Corporation 2025
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#     http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import absolute_import, division, print_function
__metaclass__ = type

DOCUMENTATION = r"""
module: zos_replace
version_added: '1.15.0'
short_description: Replace all instances of a pattern within a file or data set.
description:
  - The module L(zos_replace.,/zos_replace.html) can replace all instances of a pattern data set.
author:
  - "Marcel Gutierrez (@AndreMarcel99)"
options:
  after:
    description:
      - If specified, only content after this match will be replaced/removed.
      - Can be used in combination with I(before).
    required: false
    type: str
  backup:
    description:
      - Specifies whether a backup of destination should be created before
        editing the source I(target).
      - When set to C(true), the module creates a backup file or data set.
      - The backup file name will be returned on either success or failure of
        module execution such that data can be retrieved.
      - Use generation data set (GDS) relative positive name. e.g. I(SOME.CREATION(+1)).
    required: false
    type: bool
    default: false
  backup_name:
    description:
      - Specify the USS file name or data set name for the destination backup.
      - If the source I(src) is a USS file or path, the backup_name name must be a file
        or path name, and the USS file or path must be an absolute path name.
      - If the source is an MVS data set, the backup_name name must be an MVS
        data set name, and the dataset must not be preallocated.
      - If the backup_name is not provided, the default backup_name name will
        be used. If the source is a USS file or path, the name of the backup
        file will be the source file or path name appended with a
        timestamp, e.g. C(/path/file_name.2020-04-23-08-32-29-bak.tar).
      - If the source is an MVS data set, it will be a data set with a random
        name generated by calling the ZOAU API. The MVS backup data set
        recovery can be done by renaming it.
      - If I(src) is a data set member and backup_name is not provided, the data set
        member will be backed up to the same partitioned data set with a randomly generated
        member name.
    required: false
    type: str
  before:
    description:
      - If specified, only content before this match will be replaced/removed.
      - Can be used in combination with I(after).
    required: false
    type: str
  encoding:
    description:
      - The character set of the source I(target). L(zos_replace,./zos_replace.html)
        requires it to be provided with correct encoding to read the content
        of a USS file or data set. If this parameter is not provided, this
        module assumes that USS file or data set is encoded in IBM-1047.
      - Supported character sets rely on the charset conversion utility (iconv)
        version; the most common character sets are supported.
    required: false
    type: str
    default: IBM-1047
  target:
    description:
      - The location can be a UNIX System Services (USS) file,
        PS (sequential data set), member of a PDS or PDSE, PDS, PDSE.
      - The USS file must be an absolute pathname.
      - Generation data set (GDS) relative name of generation already
        created. e.g. I(SOME.CREATION(-1)).
    required: true
    type: str
    aliases: [ src, path, destfile ]
  regexp:
    description:
      - The regular expression to look for in the contents of the file.
    required: true
    type: str
  replace:
    description:
      - The string to replace regexp matches.
      - If not set, matches are removed entirely.
    required: false
    type: str
    default: ""
"""

EXAMPLES = r"""

"""

RETURN = r"""

"""

import os
import re
import codecs
import shutil
import tempfile
import traceback
from ansible.module_utils.basic import AnsibleModule

from ansible_collections.ibm.ibm_zos_core.plugins.module_utils import (
    better_arg_parser,
    data_set
)

from ansible_collections.ibm.ibm_zos_core.plugins.module_utils.import_handler import (
    ZOAUImportError,
)

try:
    from zoautil_py import datasets, zoau_io
except Exception:
    datasets = ZOAUImportError(traceback.format_exc())
    zoau_io = ZOAUImportError(traceback.format_exc())


def solve_src_name(module, name):
    """Function to solve and validate the exist of the dataset or uss file.

    Parameters
    ----------
        module : object
            Ansible object to execute commands.
        name : str
            Name of the src

    Returns:
        str: Name of the src.

    """
    if "/" in name:
        if os.path.exists(name):
            if os.path.isfile(name):
                return name
            else:
                module.fail_json(msg=f"Target {name} uss need to be a file not folder.")
        else:
            module.fail_json(msg=f"File {name} uss does not exists.")
    else:
        try:
            dataset = data_set.MVSDataSet(
                name=name
            )
        except Exception:
            messageDict = dict(msg="Unable to resolve name of data set {name}.")
            module.fail_json(**messageDict)

        ds_utils = data_set.DataSetUtils(name)
        if not ds_utils.exists():
            module.fail_json(msg=f"{name} does NOT exist.")

        return dataset.name


def replace_text(content, regexp, replace):
    """Function received the test to work on it to find the regexp
    expected to be replaced.

    Parameters
    ----------
        content : list
            The part or full text to be modified
        regexp : str
            The str that will be search to be replaced
        replace : str
            The str to replace on the text

    Returns:
        list: the new array of lines with the content replaced
    """
    full_text = "\n".join(content)

    pattern = re.compile(regexp, re.MULTILINE | re.DOTALL)
    modified_text = pattern.sub(replace, full_text)

    return modified_text.split("\n")


def replace_uss(file, regexp, replace, after="", before=""):

    with open(file, "r") as content_file:
        file_content = content_file.read()

    decode_list = [codecs.decode(record, "cp1047") for record in file_content]

    if after:
        line_counter = 0
        pattern_begin = re.compile(after, re.DOTALL)
        for line in decode_list:
            if pattern_begin.match(line) is not None:
                line_counter += 1
                break
            line_counter += 1
        begin_block_code = line_counter
        if before:
            pattern_end = re.compile(before, re.DOTALL)
            for line in decode_list:
                if pattern_end.match(line) is not None:
                    line_counter += 1
                    break
                line_counter += 1
            end_block_code = line_counter
            nex_text = replace_text(decode_list[begin_block_code: end_block_code:], regex=regexp, replace=replace)
        else:
            nex_text = replace_text(content=decode_list[begin_block_code:], regex=regexp, replace=replace)

    elif before:
        last_line = len(decode_list)
        pattern_end = re.compile(before, re.DOTALL)
        for line in reversed(decode_list):
            if pattern_end.match(line) is not None:
                last_line -= 1
                break
            last_line -=1
        end_block_code = last_line
        nex_text = replace_text(content=decode_list[:end_block_code], regex=regexp, replace=replace)

    else:
        nex_text = replace_text(content=decode_list, regex=regexp, replace=replace)

    return 0


def replace_ds(ds, regexp, replace, after="", before=""):

    with zoau_io.RecordIO(f"//'{ds}'") as dataset_read:
        dataset_content = dataset_read.readrecords()

    decode_list = [codecs.decode(record, "cp1047") for record in dataset_content]

    if after:
        line_counter = 0
        pattern_begin = re.compile(after, re.DOTALL)
        for line in decode_list:
            if pattern_begin.match(line) is not None:
                line_counter += 1
                break
            line_counter += 1
        begin_block_code = line_counter
        if before:
            pattern_end = re.compile(before, re.DOTALL)
            for line in decode_list:
                if pattern_end.match(line) is not None:
                    line_counter += 1
                    break
                line_counter += 1
            end_block_code = line_counter
            replace_text(decode_list[begin_block_code: end_block_code:], regex=regexp, replace=replace)
        else:
            replace_text(content=decode_list[begin_block_code:], regex=regexp, replace=replace)

    elif before:
        last_line = len(decode_list)
        pattern_end = re.compile(before, re.DOTALL)
        for line in reversed(decode_list):
            if pattern_end.match(line) is not None:
                last_line -= 1
                break
            last_line -=1
        end_block_code = last_line
        replace_text(content=decode_list[:end_block_code], regex=regexp, replace=replace)

    else:
        replace_text(content=decode_list, regex=regexp, replace=replace)

    return 0


def run_module():
    module = AnsibleModule(
        argument_spec=dict(
            after=dict(type='str'),
            backup=dict(type='bool', default=False, required=False),
            backup_name=dict(type='str', default=None, required=False),
            before=dict(type='str'),
            encoding=dict(type='str', default='IBM-1047', required=False),
            target=dict(type="str", required=True, aliases=['src', 'path', 'destfile']),
            regexp=dict(type="str", required=True),
            replace=dict(type='str', default=""),
        ),
        supports_check_mode=False
    )
    args_def = dict(
        after=dict(type='str'),
        backup=dict(type='bool', default=False, required=False),
        backup_name=dict(type='data_set_or_path', default=None, required=False),
        before=dict(type='str'),
        encoding=dict(type='str', default='IBM-1047', required=False),
        target=dict(type="data_set_or_path", required=True, aliases=['src', 'path', 'destfile']),
        regexp=dict(type="str", required=True),
        replace=dict(type='str', default=""),
    )

    try:
        parser = better_arg_parser.BetterArgParser(args_def)
        parsed_args = parser.parse_args(module.params)
        module.params = parsed_args
    except ValueError as err:
        module.fail_json(
            msg='Parameter verification failed.',
            stderr=str(err)
        )

    src = module.params.get("target")
    src = solve_src_name(module=module, name=src)
    uss = True if "/" in src else False
    after = module.params.get("after")
    before = module.params.get("before")
    regexp = module.params.get("regexp")
    replace = module.params.get("replace")

    encoding = module.params.get("encoding")
    backup = module.params.get("backup")
    backup_name = module.params.get("backup_name")

    if uss:
        full_text = replace_uss(file=src, regexp=regexp, replace=replace, after=after, before=before)
        tmp_file = tempfile.NamedTemporaryFile(delete=False)
        tmp_file = tmp_file.name
        try:
            with open(tmp_file, 'w') as f:
                for line in full_text:
                    f.write(f"{line}\n")
        except Exception as e:
            os.remove(tmp_file)
            module.fail_json(
                msg=f"Unable to write on data set {src}. {e}",
                #stderr=str(res_args),
            )
        try:
            f = open(src, 'r+')
            f.truncate(0)
            shutil.copyfile(tmp_file, src)
        finally:
            os.remove(tmp_file)

    else:
        full_text = replace_ds(ds=src, regexp=regexp, replace=replace, after=after, before=before)
        bk_ds = datasets.tmp_name()
        datasets.create(name=bk_ds, dataset_type="SEQ")
        try:
            for line in full_text:
                rc_write = datasets.write(dataset_name=bk_ds, content=line.rstrip(), append=True)
                if rc_write != 0:
                    raise Exception("Non zero return code from datasets.write.")
        except Exception as e:
            datasets.delete(dataset=bk_ds)
            module.fail_json(
                msg=f"Unable to write on data set {src}. {e}",
                #stderr=str(res_args),
            )
        try:
            datasets.delete(dataset=src)
            datasets.copy(source=bk_ds, target=src)
        finally:
            datasets.delete(dataset=bk_ds)


    result = dict()
    result["target"] = src
    result["found"] = 0

def main():
    run_module()


if __name__ == '__main__':
    main()
